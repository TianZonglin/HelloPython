print('hello world')
print("hello world")
print('hello','world')

ERROR:print 'hello'
ERROR:print "hello"

////Python基本数据类型
类型：Number包括整数+小数
整数：int
浮点数：float（不分精度）
布尔型：bool
复数：complex // 36j

----------简单运算--------------

判断数据类型 type(param)
类型合并原则：向精度更高的方向合并，结果为高精度
type(1+1.1111111)  为float类型
type(1*1.1111111) 为float类型
type(2/2) float
type(2//2) int 结果为整形

2/2 = 1.0
2//2 = 1

1//2 = 0 
1/2 = 0.5

符号 /  自动转换类型
符号 // 整除，向下取整

py2 has long but py3 dropped
ERROR：数字加字符串 不同于Java
----------进制---------------------

type(0xFFFFF) 均为int类型
但是，其默认转为进制计算，如下：
>>> 0xFFFFF
1048575

逗号运算符，自动拼为元组
>>> 0x0,'1'
(0, '1')
可以混合，可以识别元组


-----------进制转换-------------------
二进制 [b]  0b0101 = 十进制 5 
八进制 [o]  0o10   = 十进制 8 
16进制 [x]  0xF    = 十进制 15

转换-利用方法   
任意进制->二进制：bin() bin(10) = '0b1010'
任意进制->十进制：int()
任意进制->16进制：hex()
任意进制->八进制：oct()

-------------布尔类型-----------------------

True  ERROR:true.TRUE

转化：int(True) = 1     bool(1) = True

注意：无论正负小数，只要非零，皆为True
>>> bool('')
False
>>> bool('a')
True
>>> bool([]) //列表
False
>>> bool([1,2,3])
True

注意：False = 0 . [] . {} . '' 。 None 均为假



--------------------字符串:str-------------------
''单引号
""双引号   
'''-'''或者"""-"""三引号 含换行的字符串输入
OK:" It's me."
OK:' It\'s me.' 可以转义
OK:' He is ". ' 双引号在内

三引号
>>> '''2'
22'
222222'
2'''''
"2'\n22'\n222222'\n2"

显示换行，需要使用print
>>> "2'\n22'\n222222'\n2"
"2'\n22'\n222222'\n2"
>>> print("2'\n22'\n222222'\n2")
2'
22'
222222'
2


IDLE特点：使用\也可以换行
>>> 'hello\
world'
'helloworld'

转义字符，与语言本身有冲突
\n  \'  \t 
单个斜杠：\\    '\\t'= '\t'
    
文件路径不允许单个\出现 C:\\windows
print('C:\\windows')
print(r'C:\windows') 字符加r之后，可以忽略转义分歧

-------字符串操作方法------
运算符：只有 + * 没有 - /
取单值：[index]
取多值：[m:n]
串合并：'a'+'b' = 'ab'
串分割：

str[index]：直接转为字符数组，

'who'[ 0] = 'w'  参数为正·是数组下标
'who'[-1] = 'o'  参数为负·是从右起第几个

str[ m : n ]：截取一段，只有m或n时都不会返回单值
str[ 起始 : 长度 ] ：
    不写起始 str[__: 长度 ]，默认为str[0 : 长度 ]
    不写长度 str[起始 : __ ]，默认为str[起始 : 截取到最右 ]
'who'[0:0] = '' 
    注意第一个参数取得不是下标，'who'[0:] = 'who'
    注意第二个参数取得不是下标，'who'[0:0] 不是 'who'[ 0] 
'who'[0:3] = 'who'
'who'[0:-2] = 'w'  
    从右起拿掉2位之后剩余‘w’
'who'[0:10] 
    多余位数自动丢弃，不会报错
'who'[3:-2] = ''        
    从左开始，数三位是o，从o开始，往左数两个，为'' 
'who'[-3:-2] = 'w'      
    从右开始，数三位是''，从''开始，即等效于'who'[0:-2] 从右往左数两个，为'w' 
'who'[-2:] = 'ho'   
    从w开始，截取到最右：ho

-----------------------表示 组 -----------------------

多种方式：
    <class 'list'> 列表[]    元素可以混合
    <class 'tuple'>元组()    元素可以混合
全空类型：
    () , []
定义方式：
    type([1,2,3,'a',False])
    [1,2,3,[True,'b'],'a'] 嵌套列表
    [,,,] 不能为空
访问方式：
    [1,2,3,4][0] = 1            取单值时，取出元素本身
    [1,2,3,4][0:3] = [1,2,3]    取多值时，取出仍为列表
操作方式：同串类似
    + 操作 ：[1,2]+[3,4] = [1, 2, 3, 4]
    * 操作 ：[1,2]*2 = [1, 2, 1, 2]     [1,2]*2 = []
    上述操作结果均为一层列表包裹

列表和元组的区别：
    对待单元素的处理不同
        type(('a')) -- <class 'str'> 作为运算符括号处理，规定
        type(['a']) -- <class 'list'> 
        定义单元素元组 type(('a',)) = ('a')
    赋值的区别
        元组(1,2)[0] = 1 是错误的，不支持赋值
        列表[1,2][0] = 1 正确，结果为[2,2]

总结：
    int，float，bool，complex   简单类型
    str，list，tuple            称之为“序列”
    “序列”的共有操作：
        取单值          序列[m]         有序号，有序
        取多值(切片)    序列[m：n]      高级用法 序列[m：n：p] 
    共有的高级方法：
        判断序列是否在本序列：in     
            'a' in 'abc'或者2 in [1,2,3]或者2 in (1,2,3)
            2 in [1,2,3] = True 反之：2 not in [1,2,3] = False
        得到序列长度：
            len(()) = 0     len('1234') = 4 
        得到序列最大最小元素：
            max(),min() 去包装的返回值
            max('abcd') = 'd'                 按ASCII（ord('')）码值，空格等照样
            max([(1,2),(1,2,3)]) = (1,2,3)    元组长度最大


------------------- 无序：集合 -----------------------
type({1,2,3,4}) = <class 'set'>

特性：
    无序        序列操作方式不适用 集合，集合元素没有一个固定下标
    不重复      {1,1,2,2,3,4} = {1,2,3,4}
    公共        len(),  in, not in
    集合运算    - & |
运算：
    差集    {1,2,3} - {1} = {2,3}
    交集    {1,2} & {2,3} = {2}
    并集    {1,2} | {2,3} = {1,2,3}
    上述运算符中均不能出现{}空集合，另外结果会自动去掉重复
注意：
    直接使用{}定义的不是空集合，其类型为字典：<class 'dict'>
    定义空集合：set()，即为type(set()) = <class 'set'>
    列表内不能含有列表或者字典元素
        {1,{1,2,3}}是错的，可以含有元组，字符串和整形的混合

------------------- 无序：字典 -----------------------------
不是序列，类似于集合，但不同
定义方式：
    {'name':'tom','sex':'wm'}  type类型是   <class 'dict'>
    
取值：通过Key访问Value
    {'name':'tom','sex':'wm'}['name'] = 'tom'
    {(1,2):'a','name':'b','sex':'wm'}[(1,2)] = 'a'
    {'name':'a','name':'b','sex':'wm'}['name'] = 'b'
    字典不能有重复键值对，如果重复，运算之前会自动去重
    字典的Key必须为不可变类型  int,str,tuple  list和set不行   
    字典的Value类型不限        {2:{2:'a'}}[2][2] = 'a'
    定义空字典：直接{}         type({}) = <class 'dict'>
    
---------------------- 基本类型大总结 ------------------------
int，float，bool，complex       
1            1.2             False      20j
str，list，tuple                
'a'          [1,2]  列表     (1,2) 元组    
set，dict                       
{1,2} 集合   {1:"2"}字典

不可变类型
    整形 布尔型 字符串 元组  int,bool,str,tuple
可变类型
    列表 集合 字典 [list],{set},{dict}
    
集合 无序，无索引，不能切片
字典 类似集合，不是序列




===================== 第二章 变量 ============================
变量不说“定义”！

使用变量    “ 变量名称 = 变量类型 ”
            a = {'name':'tom','sex':'wm'}
变量命名规范：
    首字母不能是数字，字母数字下划线组合，_1 = 1  是合法的
    注意：保留字不能用，但函数名可以用，但不要用！
        type = 1;不报错，但是type(1)时则报错！
    变量是动态赋值，num = 1; num = True 是合法的

变量接收的赋值类型，后续操作若操作引用类型，则源头修改，下游皆改
    对一般赋值·后来者与数据源无关   [值类型]
        a = 1;b = a;a = 2;          print(b) = 1
        a = 'a';b = a;a = 2;        print(b) = 'a'
        a = (1,2);b = a;a = 2;      print(b) = (1,2)
    对于传递后修改了数据源的动态类型，那么则会传导!!    [引用类型]
        a = [1,2];b = a;a[0] = 2;   print(b) = [2,2]    //注意！
        a = (1,2);b = a;a[0] = 2;   print(b)            //会报错
    总结：（两类型与是否为序列无关）
        值类型：    字符串str、整形int、元组tuple
        引用类型：  列表list、集合set，字典dict
对于字符串(字符串是值类型，不可改变)相加：
    对于a = '1',a += '2' 结果为'12'，其并不是原串的改变
    >>> a = '1'     id(a) = 10322752    初始赋值的内存地址
    >>> a += '2'    id(a) = 55621088    相加后a的地址发生改变
    上述结果不违背str是值类型，故'string'[0] = 'a',是错误的！
------------------ tuple list的区别 ------------------------
访问：
    两者均可通过Array[id]访问元素，并可以多维访问[i][j]
    a = (1,2,[3,4,[5]]);    a[2][2][0] = 5
赋值：
    列表list：
        >>> a = [1,2,3]     hex(id(a)) = '0x34d2f48'
        >>> a[0] = 2        hex(id(a)) = '0x34d2f48'
    元组tuple：
        >>> a = (1,2,3) a[0] = 2 这是错误的，因为元组是值类型
    注意：对于元组中的可变类型，依然可以动态修改
        >>> a = (1,2,[3,4,[5]]) a[2][0] = 8;
        >>> a = (1,2,[8,4,[5]]) 正常完成修改
追加元素：
    列表list：
        >>> b = [1,2]    b.append(4)  b = [1, 2, 4]
    元组tuple：
        值类型，没有append方法
总结：列表是动态的，元组定义后不可变的，这是针对元素的说法，
      与包装外皮无关，比如元组中的列表依然可以修改

----------------------------- 运算符 ----------------------------

python特有的运算符
    算术运算符
        +       'a' + 'b' = 'ab'
        -       {1,2} - {1} = {2}
        *       [1,2] * 2 = [1,2,1,2]
        /       3/2 = 1.5 3//2 = 1
        %       5 % 2 = 1           取余
        **      2 ** 2 = 4          N次方
    赋值运算符          
        *=      算数运算符后跟等号
                python没有自增运算符，i++ 是错误的
    比较、关系运算符    
        ==      比较两个类型是否相等，
                对于元组等复杂类型，元素类型相同时可以比较长度
                返回结果是bool类型！
    逻辑运算符          
        and     True and True = True            且
        or      False or False = False          或
        not     单目运算符：not False = True    非
                返回值不一定是bool类型的形式！
    成员运算符          
        in      在，一个元素是否在另外一组元素
        not in  不在
                返回值为bool类型！
    身份运算符          
        is      (object)
        is not  (object)
                返回值为bool类型!
    位运算符
        &       按位与，双目
        |       按位或
        ^       按位异或
        ~       按位取反
        <<      左移
        >>      右移
                注意：均会转化为二进制数运算
                
运算符结合顺序：从右往左
    b = 1, b+=b>=1 即 b = b + True
    
复杂类型的比较：
    'a' > 'b' = False       因为 ord('a') < ord('b')
    'ab'> 'aa'= True        字典比较
    [1,2] < [2,3] = True    相同的按元素比较
    (1,2) < (2,3) = True    同上，注意 (1,2) < (2,1) = True
    对于动态类型列表和集合{}，其不能比较，返回值均为false
    
复杂类型逻辑运算：
    not 0 = True
    not 'a' = False 
    本质只能操作bool类型，整形和字符串都能转换为bool类型
    转换规则：
        对于int，float，0被认为是False，其余均是True
        对于str，空串''被认为是False，其余均是True
        对于list，空列表[]被认为是False，其余均为True
        其余类似
        [] or [1] = [1] 返回的是True值的形式，但不一定是bool型
        '' and 'a' = '' 返回False值的形式，''即为False形式
        注意：
            1 and 2 = 2， 2 and 1 = 1 必须检测后者，就近返回
            1 or 2  = 1， 2 or 1 = 2  此处只需看前者，就近返回
            
复杂成员运算：
    对于非数值类型，str、tuple、list、set、dict判断元素在不在
        对于除字典以外：'a' in (1,(1,'a')) = False，只
        对于dict：只能检查key值在不在，不能检查value
    对于数值类型，包括int、float、bool，不能使用，否则会报错
    
身份运算符：
    与关系运算符 == 无关！
    身份符比较的是身份！身份：暂时理解为内存地址的比较
    >>> 1 is 1 = True        值类型
    >>> {1} is {1} = False   引用型
    >>> (1,2) == (2,1) False 序列，位置固定，按位置比较
    >>> (1,2) is (2,1) False 内存不同
    >>> {1,2} == {2,1} True  无序集合，表示内容相同！不说‘相等’！
    >>> {1,2} is {2,1} False 内存不同
    
对于两个变量、或对象的三特征：值(==)、身份(is)、类型(isinstance)    
    a = 'hello', type(a)==str是True，这种方式不推荐
    注意：
        上述方法不能判断a的子类是否是str
        下面的方法可以判断a的子类是不是某种类型
    判断对象类型：
        isinstance(a,str) = True
        isinstance(a,(int,str))) = True 可以一次判断多种类型
        
位运算符
    按位与      2 & 3 = 0b10 & 0b11 = 0b10 = 2    
    按位或      2 | 3 = 0b10 & 0b11 = 0b11 = 3
    按位异或    2 ^ 3 = 0b10 & 0b11 = 0b01 = 1